/* eslint-disable no-restricted-globals */

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute, setCatchHandler } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst, NetworkOnly } from 'workbox-strategies';
import { BackgroundSyncPlugin } from 'workbox-background-sync';
import { matchPrecache } from 'workbox-precaching';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute([{"revision":"5a76c4bc8e553ceb63ba73b7280eb03b","url":"android/android-launchericon-144-144.png"},{"revision":"8ea05e15a927b893ca6fc8cdfd593373","url":"android/android-launchericon-192-192.png"},{"revision":"685832cba81b7eb4e2c383eb4673a85e","url":"android/android-launchericon-48-48.png"},{"revision":"07ba8c5f5b00089222373d9c44425394","url":"android/android-launchericon-512-512.png"},{"revision":"bc99234a4dd9c1e072e1f0153483bd72","url":"android/android-launchericon-72-72.png"},{"revision":"9b03133961813737d54b542c430787df","url":"android/android-launchericon-96-96.png"},{"revision":"c92b85a5b907c70211f4ec25e29a8c4a","url":"favicon.ico"},{"revision":"d46986de43a300d31865488d84fab2a1","url":"icons/Appsplash.png"},{"revision":"1e619fc7a05524dd6b8fb458af935faa","url":"icons/Browser.png"},{"revision":"d1de43ad9d6c8336ee0122544f2cd83e","url":"index.html"},{"revision":"33dbdd0177549353eeeb785d02c294af","url":"logo192.png"},{"revision":"917515db74ea8d1aee6a246cfbcc0b45","url":"logo512.png"},{"revision":"24f0e4b24cc7901ed02ab2e82677e994","url":"offline.html"},{"revision":"2e12429683f67a36b9e18f224d8f975a","url":"static/css/main.7cba014b.css"},{"revision":"bab64681fe14e5e1cba172c251f4f9d2","url":"static/js/16.3f4e6a29.chunk.js"},{"revision":"37e2afbb641871f00a97617eacfad9d3","url":"static/js/223.936c3485.chunk.js"},{"revision":"127397b23a9c3034e17b3c69aa256ff9","url":"static/js/228.c7a958f9.chunk.js"},{"revision":"50a0063135cf59205af0a1d6ce16d0f0","url":"static/js/249.0dc2b056.chunk.js"},{"revision":"cf5c3315a59eaab3a4bf285bd14598a5","url":"static/js/295.4bf9dda3.chunk.js"},{"revision":"2d5a043de4ab74ec0adb5f07cf937169","url":"static/js/371.00be7d0f.chunk.js"},{"revision":"84f2f1251e80e44879ea916ed8c54e22","url":"static/js/388.8bc7c72b.chunk.js"},{"revision":"bcd2c5add90e54e37d90484bb8fa103b","url":"static/js/446.dffd9c5e.chunk.js"},{"revision":"c8ce025abaee91ea8ec3850b25453d0e","url":"static/js/490.f9649aad.chunk.js"},{"revision":"fc71b03f80c659ec581983419f27f251","url":"static/js/55.493ac6df.chunk.js"},{"revision":"d9c491b306c0beb7708ff34f48855aa2","url":"static/js/583.d6f3a6b9.chunk.js"},{"revision":"56cc21ed91275e97a5db8cd616d9fe6b","url":"static/js/586.c9b9518b.chunk.js"},{"revision":"73d3b4784ed5b4761a73d478ea1e62b7","url":"static/js/617.b2331191.chunk.js"},{"revision":"90085f3b5cba19c630b370d9869ed5bf","url":"static/js/714.dd9b813d.chunk.js"},{"revision":"c54471d1f88201cc5221e6a40af8e152","url":"static/js/733.14e41e9c.chunk.js"},{"revision":"53b1a5186d31cd55e19785db134d5ed5","url":"static/js/779.b3285539.chunk.js"},{"revision":"de50fbd0c5325a5dd35cb027bdf55788","url":"static/js/808.ad74101b.chunk.js"},{"revision":"a7e7a7e9fce6f9cd7682292489778962","url":"static/js/882.31c5fab4.chunk.js"},{"revision":"5639e3aa5144d4c97407aedc1af18202","url":"static/js/main.59c2abe7.js"}]);
precacheAndRoute([{ url: '/offline.html', revision: '1' }]);


// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\.[^/]+
);
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_,
    // it's likely an internal request made by the server, so skip.
    if (url.pathname.startsWith('/_/')) {
      return false;
    }

    // If this looks like a URL for a resource,
    // because it contains a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => url.origin === self.location.origin && url.pathname.endsWith('.png'),
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently-used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// Cache Google Fonts
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com' || url.origin === 'https://fonts.gstatic.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts',
    plugins: [
      new ExpirationPlugin({ maxEntries: 20 }),
    ],
  })
);

// Background sync for mutations
const bgSyncPlugin = new BackgroundSyncPlugin('mutations-queue', {
  maxRetentionTime: 24 * 60, // Retry for max 24 Hours
});

// Cache Firestore data with background sync for POST requests
registerRoute(
    ({ url, request }) =>
      url.host.includes('firestore.googleapis.com') && request.method === 'POST',
    new NetworkOnly({
      plugins: [bgSyncPlugin],
    })
  );
  
  registerRoute(
    ({ url, request }) =>
      url.host.includes('firestore.googleapis.com') && request.method === 'GET',
    new NetworkFirst({
      cacheName: 'firestore-data',
      plugins: [
        new ExpirationPlugin({
          maxEntries: 50,
          maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
        }),
      ],
    })
  );

self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Offline fallback
setCatchHandler(async ({ event }) => {
  // Return the precached offline page if a navigation fails
  if (event.request.destination === 'document') {
    return matchPrecache('/offline.html');
  }

  return Response.error();
});
